{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/ufriends%20version%201/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient | undefined }\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: [\"error\", \"warn\"],\n  })\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;QAAS;KAAO;AACxB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/ufriends%20version%201/app/api/pricing/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { prisma } from \"@/lib/db\"\n\nfunction buildParamsFromSearch(searchParams: URLSearchParams) {\n  const known = new Set([\"category\", \"subservice\", \"variant\", \"role\", \"tier\", \"serviceSlug\"]) // exclude aliases from dynamic params\n  const params: Record<string, string> = {}\n  for (const [k, v] of searchParams.entries()) {\n    if (!known.has(k)) params[k] = v\n  }\n  return params\n}\n\nfunction stableParamsKey(params: Record<string, string>): string {\n  const keys = Object.keys(params)\n  if (!keys.length) return \"\"\n  keys.sort()\n  return keys.map((k) => `${k}=${params[k]}`).join(\"|\")\n}\n\n// Normalize params for case-insensitive comparison\nfunction toLowerParams(params: Record<string, string>): Record<string, string> {\n  const out: Record<string, string> = {}\n  for (const [k, v] of Object.entries(params)) {\n    out[k] = String(v).toLowerCase()\n  }\n  return out\n}\n\nfunction stableParamsKeyLower(params: Record<string, string>): string {\n  const lower = toLowerParams(params)\n  const keys = Object.keys(lower)\n  if (!keys.length) return \"\"\n  keys.sort()\n  return keys.map((k) => `${k}=${lower[k]}`).join(\"|\")\n}\n\n// Public pricing API (catalog-based)\n// GET /api/pricing?category=X&subservice=Y&variant=Z&role=user|marketer\nexport async function GET(req: NextRequest) {\n  try {\n    const { searchParams } = new URL(req.url)\n    let category = (searchParams.get(\"category\") || \"\").trim()\n    let subservice = (searchParams.get(\"subservice\") || \"\").trim()\n    let variant = (searchParams.get(\"variant\") || \"\").trim()\n    const tier = (searchParams.get(\"tier\") || \"\").trim().toLowerCase()\n    let role = ((searchParams.get(\"role\") || tier || \"user\").trim().toLowerCase()) as \"user\" | \"marketer\"\n    const serviceSlug = (searchParams.get(\"serviceSlug\") || \"\").trim()\n\n    // Allow serviceSlug alias: e.g., bills.cable.dstv.padi => category=bills, subservice=cable, variant=dstv.padi\n    if (serviceSlug && (!category || !subservice)) {\n      const parts = serviceSlug.split(\".\").filter(Boolean)\n      if (parts.length >= 2) {\n        category = parts[0]\n        subservice = parts[1]\n        variant = parts.slice(2).join(\".\")\n      }\n    }\n    const dynParams = buildParamsFromSearch(searchParams)\n    const paramsKey = stableParamsKey(dynParams)\n    const paramsKeyLower = stableParamsKeyLower(dynParams)\n\n    if (!category || !subservice) {\n      return NextResponse.json({ error: \"category and subservice are required\" }, { status: 400 })\n    }\n\n    // Fallback hierarchy search order:\n    // 1) Exact: category + subservice + variant\n    // 2) Variant fallback: category + subservice + \"\"\n    // 3) Subservice fallback: category + \"\" + \"\" (category-level)\n    // Expand known aliases for subservice to improve match robustness (e.g., CAC pages)\n    const expandSubserviceAliases = (cat: string, sub: string): string[] => {\n      const c = String(cat || \"\").trim().toLowerCase()\n      const s = String(sub || \"\").trim().toLowerCase()\n      // Only alias within CAC to avoid cross-category noise\n      if (c === \"cac\") {\n        const infoAliases = [\"info\", \"certificate\", \"certification\", \"retrieval\", \"retrieval of certification\", \"retrieval-of-certification\"]\n        const statusAliases = [\"status\", \"status report\", \"status-report\", \"statusreport\", \"retrieval status\", \"retrieval-status\", \"retrieval-status-report\"]\n        if (infoAliases.includes(s)) return infoAliases\n        if (statusAliases.includes(s)) return statusAliases\n      }\n      // BVN: support common aliases for central risk management\n      if (c === \"bvn\") {\n        const centralRiskAliases = [\"central-risk\", \"central risk\", \"central_risk\", \"crm\", \"centralrisk\"]\n        if (centralRiskAliases.includes(s)) return centralRiskAliases\n      }\n      return [sub]\n    }\n\n    const subAliases = expandSubserviceAliases(category, subservice)\n    const variantToUse = variant || \"\"\n    const searchOrder: Array<{ where: { category: string; subservice: string; variant: string } }> = []\n    // Build search order for each alias with standard fallbacks\n    for (const sub of subAliases) {\n      searchOrder.push({ where: { category, subservice: sub, variant: variantToUse } })\n      searchOrder.push({ where: { category, subservice: sub, variant: \"\" } })\n    }\n    // Category-level fallback (no subservice/variant)\n    searchOrder.push({ where: { category, subservice: \"\", variant: \"\" } })\n\n    let foundPricing: any = null\n    let foundCatalog: any = null\n\n    for (const level of searchOrder) {\n      // Load candidates for this level\n      const candidates = await prisma.catalogPricing.findMany({\n        where: {\n          category: { equals: level.where.category, mode: \"insensitive\" },\n          subservice: { equals: level.where.subservice, mode: \"insensitive\" },\n          variant: { equals: level.where.variant, mode: \"insensitive\" },\n        },\n        orderBy: { updatedAt: \"desc\" },\n      })\n\n      if (!candidates.length) {\n        // Try next fallback level\n        continue\n      }\n\n      // Exact match by paramsKey (case-insensitive via normalized recompute)\n      let pricing = candidates.find((p) => {\n        const pParams = ((p.parameters as any) || {}) as Record<string, any>\n        const normalized: Record<string, string> = {}\n        for (const [k, v] of Object.entries(pParams)) normalized[k] = String(v).toLowerCase()\n        const pKeyLower = stableParamsKeyLower(normalized)\n        return pKeyLower === paramsKeyLower\n      })\n\n      // Best-match fallback: choose the entry whose parameters are a subset and has the highest match count\n      if (!pricing) {\n        let best: typeof candidates[number] | undefined\n        let bestScore = -1\n        for (const p of candidates) {\n          const paramsObj = ((p.parameters as any) || {}) as Record<string, any>\n          const keys = Object.keys(paramsObj)\n          if (!keys.length) {\n            // Base entry with no parameters: score 0\n            if (bestScore < 0) { best = p; bestScore = 0 }\n            continue\n          }\n          // Count matching key=value pairs\n          let score = 0\n          for (const k of keys) {\n            const reqVal = dynParams[k]\n            const candVal = paramsObj[k]\n            if (reqVal !== undefined && String(reqVal).toLowerCase() === String(candVal).toLowerCase()) {\n              score += 1\n            } else {\n              // Required param mismatch; penalize heavily\n              score = -1\n              break\n            }\n          }\n          if (score >= 0 && score > bestScore) {\n            best = p\n            bestScore = score\n          }\n        }\n        pricing = best\n      }\n\n      if (pricing) {\n        foundPricing = pricing\n        // Resolve catalog for the selected level to return metadata\n        // Catalog lookup may be case-sensitive; attempt insensitive fallback\n        foundCatalog = await prisma.serviceCatalog.findFirst({\n          where: {\n            category: { equals: level.where.category, mode: \"insensitive\" },\n            subservice: { equals: level.where.subservice, mode: \"insensitive\" },\n            variant: { equals: level.where.variant, mode: \"insensitive\" },\n          },\n        }).catch(() => null)\n        break\n      }\n    }\n\n    if (!foundPricing) {\n      return NextResponse.json({ ok: true, price: null, detail: \"No matching price for given parameters\" })\n    }\n\n    const selected = role === \"marketer\" ? Number(foundPricing.marketerPrice) : Number(foundPricing.userPrice)\n    return NextResponse.json({\n      ok: true,\n      catalog: foundCatalog\n        ? { id: foundCatalog.id, category: foundCatalog.category, subservice: foundCatalog.subservice, variant: foundCatalog.variant }\n        : { id: null, category, subservice, variant: variant || \"\" },\n      pricing: {\n        basePrice: Number(foundPricing.basePrice),\n        userPrice: Number(foundPricing.userPrice),\n        marketerPrice: Number(foundPricing.marketerPrice),\n        updatedAt: foundPricing.updatedAt,\n      },\n      role,\n      parameters: foundPricing.parameters ?? null,\n      paramsKey: String(foundPricing.paramsKey || \"\"),\n      price: selected,\n    })\n  } catch (err) {\n    return NextResponse.json({ error: \"Failed to fetch pricing\", detail: String(err) }, { status: 500 })\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}