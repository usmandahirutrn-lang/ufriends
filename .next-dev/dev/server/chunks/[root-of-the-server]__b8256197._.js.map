{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/ufriends%20version%201/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient | undefined }\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: [\"error\", \"warn\"],\n  })\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;QAAS;KAAO;AACxB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/ufriends%20version%201/app/api/pricing/parameters/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { prisma } from \"@/lib/db\"\nimport { Prisma } from \"@prisma/client\"\n\n// GET /api/pricing/parameters?category=X&subservice=Y&variant=Z\n// Returns discovered parameter keys and distinct values from pricing entries\nexport async function GET(req: NextRequest) {\n  try {\n    const { searchParams } = new URL(req.url)\n    const category = (searchParams.get(\"category\") || \"\").trim()\n    const subservice = (searchParams.get(\"subservice\") || \"\").trim()\n    const variant = (searchParams.get(\"variant\") || \"\").trim()\n\n    if (!category || !subservice) {\n      return NextResponse.json({ error: \"category and subservice are required\" }, { status: 400 })\n    }\n\n    // Expand CAC subservice aliases to aggregate parameter options across differently named entries\n    const expandSubserviceAliases = (cat: string, sub: string): string[] => {\n      const c = String(cat || \"\").trim().toLowerCase()\n      const s = String(sub || \"\").trim().toLowerCase()\n      if (c === \"cac\") {\n        const infoAliases = [\"info\", \"certificate\", \"certification\", \"retrieval\", \"retrieval of certification\", \"retrieval-of-certification\"]\n        const statusAliases = [\"status\", \"status report\", \"status-report\", \"statusreport\", \"retrieval status\", \"retrieval-status\", \"retrieval-status-report\"]\n        if (infoAliases.includes(s)) return infoAliases\n        if (statusAliases.includes(s)) return statusAliases\n      }\n      return [sub]\n    }\n\n    const aliases = expandSubserviceAliases(category, subservice)\n    const variantToUse = variant || \"\"\n    const rows = await prisma.catalogPricing.findMany({\n      where: {\n        category: { equals: category, mode: Prisma.QueryMode.insensitive },\n        OR: aliases.map((sub) => ({\n          subservice: { equals: sub, mode: Prisma.QueryMode.insensitive },\n          variant: { equals: variantToUse, mode: Prisma.QueryMode.insensitive },\n        })).concat(\n          aliases.map((sub) => ({\n            subservice: { equals: sub, mode: Prisma.QueryMode.insensitive },\n            variant: { equals: \"\", mode: Prisma.QueryMode.insensitive },\n          }))\n        ),\n      },\n      select: { parameters: true },\n    })\n\n    const options: Record<string, Set<string>> = {}\n    for (const r of rows) {\n      const params = (r.parameters as any) || {}\n      if (!params || typeof params !== \"object\" || Array.isArray(params)) continue\n      for (const [k, v] of Object.entries(params)) {\n        if (!(k in options)) options[k] = new Set<string>()\n        options[k].add(String(v).toLowerCase())\n      }\n    }\n\n    const normalizedOptions: Record<string, string[]> = {}\n    for (const [k, set] of Object.entries(options)) {\n      normalizedOptions[k] = Array.from(set.values()).sort()\n    }\n\n    return NextResponse.json({ ok: true, category, subservice, variant: variant || \"\", options: normalizedOptions })\n  } catch (err) {\n    return NextResponse.json({ error: \"Failed to fetch parameter options\", detail: String(err) }, { status: 500 })\n  }\n}"],"names":[],"mappings":"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","debugId":null}}]
}