{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/ufriends%20version%201/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\"\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient | undefined }\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: [\"error\", \"warn\"],\n  })\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK;QAAC;QAAS;KAAO;AACxB;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/ufriends%20version%201/lib/validation.ts"],"sourcesContent":["import { z } from \"zod\"\nimport { ZodXssSanitizer, ACTION_LEVELS } from \"zod-xss-sanitizer\"\n\n// Shared XSS sanitizer instance\nexport const sanitizer = ZodXssSanitizer.sanitizer({ actionLevel: ACTION_LEVELS.SANITIZE })\n\nexport function sanitizeEmail(input: string) {\n  return sanitizer.parse(z.string().trim().toLowerCase().email().parse(input))\n}\n\nexport function sanitizeString(input: string) {\n  return sanitizer.parse(z.string().trim().min(1).parse(input))\n}\n\nexport function sanitizePhone(input: string) {\n  const schema = z.string().trim().regex(/^\\+?[0-9]{10,15}$/i, { message: \"Invalid phone\" })\n  return sanitizer.parse(schema.parse(input))\n}\n\nexport function isValidUrl(input: string) {\n  const res = z.string().url().safeParse(input)\n  return res.success\n}"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;;;AAGO,MAAM,YAAY,8KAAe,CAAC,SAAS,CAAC;IAAE,aAAa,4KAAa,CAAC,QAAQ;AAAC;AAElF,SAAS,cAAc,KAAa;IACzC,OAAO,UAAU,KAAK,CAAC,yKAAC,CAAC,MAAM,GAAG,IAAI,GAAG,WAAW,GAAG,KAAK,GAAG,KAAK,CAAC;AACvE;AAEO,SAAS,eAAe,KAAa;IAC1C,OAAO,UAAU,KAAK,CAAC,yKAAC,CAAC,MAAM,GAAG,IAAI,GAAG,GAAG,CAAC,GAAG,KAAK,CAAC;AACxD;AAEO,SAAS,cAAc,KAAa;IACzC,MAAM,SAAS,yKAAC,CAAC,MAAM,GAAG,IAAI,GAAG,KAAK,CAAC,sBAAsB;QAAE,SAAS;IAAgB;IACxF,OAAO,UAAU,KAAK,CAAC,OAAO,KAAK,CAAC;AACtC;AAEO,SAAS,WAAW,KAAa;IACtC,MAAM,MAAM,yKAAC,CAAC,MAAM,GAAG,GAAG,GAAG,SAAS,CAAC;IACvC,OAAO,IAAI,OAAO;AACpB","debugId":null}},
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/DELL/Downloads/ufriends%20version%201/app/api/auth/verify-password/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\r\nimport { prisma } from \"@/lib/db\"\r\nimport bcrypt from \"bcryptjs\"\r\nimport { z } from \"zod\"\r\nimport { sanitizer } from \"@/lib/validation\"\r\nimport arcjet, { shield } from \"@arcjet/next\"\r\n\r\n// Lighter Arcjet instance for password check - Shield only, no email validation overhead if not needed\r\n// or we can reuse existing if we want consistency. For now, let's keep it minimal.\r\nconst aj = process.env.ARCJET_KEY\r\n    ? arcjet({\r\n        key: process.env.ARCJET_KEY!,\r\n        rules: [\r\n            shield({ mode: \"LIVE\" }),\r\n        ],\r\n    })\r\n    : null\r\n\r\nconst verifySchema = z.object({\r\n    email: z.string().trim().toLowerCase().email(),\r\n    password: z.string().min(1),\r\n})\r\n\r\nexport async function POST(req: Request) {\r\n    try {\r\n        const raw = await req.json()\r\n        const parsed = verifySchema.safeParse(raw)\r\n        if (!parsed.success) {\r\n            return NextResponse.json({ error: \"Invalid input\" }, { status: 422 })\r\n        }\r\n\r\n        const email = sanitizer.parse(parsed.data.email)\r\n        const password = parsed.data.password\r\n\r\n        // Basic protection against bots\r\n        if (aj) {\r\n            const decision = await aj.protect(req as any)\r\n            if (decision.isDenied()) {\r\n                return NextResponse.json({ error: \"Forbidden\" }, { status: 403 })\r\n            }\r\n        }\r\n\r\n        const user = await prisma.user.findUnique({\r\n            where: { email },\r\n            select: { passwordHash: true }\r\n        })\r\n\r\n        if (!user) {\r\n            // Use generic error to prevent enumeration\r\n            return NextResponse.json({ error: \"Invalid email or password\" }, { status: 401 })\r\n        }\r\n\r\n        const ok = await bcrypt.compare(password, user.passwordHash)\r\n        if (!ok) {\r\n            return NextResponse.json({ error: \"Invalid email or password\" }, { status: 401 })\r\n        }\r\n\r\n        return NextResponse.json({ ok: true })\r\n    } catch (err) {\r\n        return NextResponse.json({ error: \"Verification failed\" }, { status: 500 })\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;AAEA,uGAAuG;AACvG,mFAAmF;AACnF,MAAM,KAAK,QAAQ,GAAG,CAAC,UAAU,GAC3B,IAAA,sKAAM,EAAC;IACL,KAAK,QAAQ,GAAG,CAAC,UAAU;IAC3B,OAAO;QACH,IAAA,2IAAM,EAAC;YAAE,MAAM;QAAO;KACzB;AACL,KACE;AAEN,MAAM,eAAe,yKAAC,CAAC,MAAM,CAAC;IAC1B,OAAO,yKAAC,CAAC,MAAM,GAAG,IAAI,GAAG,WAAW,GAAG,KAAK;IAC5C,UAAU,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC;AAC7B;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,MAAM,MAAM,IAAI,IAAI;QAC1B,MAAM,SAAS,aAAa,SAAS,CAAC;QACtC,IAAI,CAAC,OAAO,OAAO,EAAE;YACjB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgB,GAAG;gBAAE,QAAQ;YAAI;QACvE;QAEA,MAAM,QAAQ,gIAAS,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC,KAAK;QAC/C,MAAM,WAAW,OAAO,IAAI,CAAC,QAAQ;QAErC,gCAAgC;QAChC,IAAI,IAAI;YACJ,MAAM,WAAW,MAAM,GAAG,OAAO,CAAC;YAClC,IAAI,SAAS,QAAQ,IAAI;gBACrB,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,OAAO;gBAAY,GAAG;oBAAE,QAAQ;gBAAI;YACnE;QACJ;QAEA,MAAM,OAAO,MAAM,qHAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,OAAO;gBAAE;YAAM;YACf,QAAQ;gBAAE,cAAc;YAAK;QACjC;QAEA,IAAI,CAAC,MAAM;YACP,2CAA2C;YAC3C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA4B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,MAAM,KAAK,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,YAAY;QAC3D,IAAI,CAAC,IAAI;YACL,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA4B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;QAAK;IACxC,EAAE,OAAO,KAAK;QACV,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAsB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACJ","debugId":null}}]
}